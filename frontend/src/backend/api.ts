/* tslint:disable */
/* eslint-disable */
/**
 * resslab_tools
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum ConnectionField {
    Id = 'id',
    ExperimentalProgram = 'experimental_program',
    Date = 'date',
    SpecimenDesignation = 'specimen_designation',
    Northridge = 'northridge',
    SpecimenType = 'specimen_type',
    Slab = 'slab',
    ConnectionType = 'connection_type',
    SectionB = 'section_b',
    DB = 'd_b',
    SteelB = 'steel_b',
    SectionC = 'section_c',
    DC = 'd_c',
    TCf = 't_cf',
    Lat = 'lat',
    Long = 'long',
    TDp = 't_dp',
    NDp = 'n_dp',
    TDpTot = 't_dp_tot'
}

/**
 * Connection
 * @export
 * @interface ConnectionModel
 */
export interface ConnectionModel {
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'experimental_program': string;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'date': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'specimen_designation': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'northridge': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'specimen_type': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionModel
     */
    'slab': boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'connection_type': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'section_b': string;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'd_b': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'steel_b': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionModel
     */
    'section_c': string;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'd_c': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    't_cf': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'long': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    't_dp': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    'n_dp': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionModel
     */
    't_dp_tot': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum ConnectionNumberField {
    Date = 'date',
    DB = 'd_b',
    DC = 'd_c',
    TCf = 't_cf',
    Lat = 'lat',
    Long = 'long',
    TDp = 't_dp',
    NDp = 'n_dp',
    TDpTot = 't_dp_tot'
}

/**
 * Count
 * @export
 * @interface CountModel
 */
export interface CountModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof CountModel
     */
    'names': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CountModel
     */
    'value': number;
}
/**
 * DownloadModel
 * @export
 * @interface DownloadModel
 */
export interface DownloadModel {
    /**
     * 
     * @type {string}
     * @memberof DownloadModel
     */
    'global_csv': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadModel
     */
    'panel_zone_csv': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * App Info
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface PageConnectionModel
 */
export interface PageConnectionModel {
    /**
     * 
     * @type {Array<ConnectionModel>}
     * @memberof PageConnectionModel
     */
    'items': Array<ConnectionModel>;
    /**
     * 
     * @type {number}
     * @memberof PageConnectionModel
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PageConnectionModel
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PageConnectionModel
     */
    'size': number;
}
/**
 * Range
 * @export
 * @interface RangeModel
 */
export interface RangeModel {
    /**
     * 
     * @type {number}
     * @memberof RangeModel
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof RangeModel
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get paginated Connections
         * @summary Get Connections
         * @param {string} [query] 
         * @param {Array<string>} [sortBy] 
         * @param {Array<boolean>} [sortDesc] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnections: async (query?: string, sortBy?: Array<string>, sortDesc?: Array<boolean>, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDesc) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get occurences count of field values
         * @summary Get Counts
         * @param {Array<ConnectionField>} fields 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounts: async (fields: Array<ConnectionField>, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fields' is not null or undefined
            assertParamExists('getCounts', 'fields', fields)
            const localVarPath = `/connections/counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Download
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getDownload', 'connectionId', connectionId)
            const localVarPath = `/connections/{connection_id}/download`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get global csv from connection
         * @summary Get Global Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalCsv: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getGlobalCsv', 'connectionId', connectionId)
            const localVarPath = `/connections/{connection_id}/globals/csv`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get global series from connection
         * @summary Get Globals
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobals: async (connectionId: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getGlobals', 'connectionId', connectionId)
            const localVarPath = `/connections/{connection_id}/globals`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get panel zone series from connection
         * @summary Get Panel Zones
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelZones: async (connectionId: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getPanelZones', 'connectionId', connectionId)
            const localVarPath = `/connections/{connection_id}/panel-zones`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get panel zone csv from connection
         * @summary Get Panel Zones Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelZonesCsv: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getPanelZonesCsv', 'connectionId', connectionId)
            const localVarPath = `/connections/{connection_id}/panel-zones/csv`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get range of field
         * @summary Get Range
         * @param {ConnectionNumberField} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRange: async (field: ConnectionNumberField, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'field' is not null or undefined
            assertParamExists('getRange', 'field', field)
            const localVarPath = `/connections/range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get paginated Connections
         * @summary Get Connections
         * @param {string} [query] 
         * @param {Array<string>} [sortBy] 
         * @param {Array<boolean>} [sortDesc] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnections(query?: string, sortBy?: Array<string>, sortDesc?: Array<boolean>, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageConnectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnections(query, sortBy, sortDesc, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get occurences count of field values
         * @summary Get Counts
         * @param {Array<ConnectionField>} fields 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCounts(fields: Array<ConnectionField>, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCounts(fields, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Download
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownload(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get global csv from connection
         * @summary Get Global Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalCsv(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalCsv(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get global series from connection
         * @summary Get Globals
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobals(connectionId: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<number>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobals(connectionId, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get panel zone series from connection
         * @summary Get Panel Zones
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPanelZones(connectionId: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<number>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPanelZones(connectionId, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get panel zone csv from connection
         * @summary Get Panel Zones Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPanelZonesCsv(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPanelZonesCsv(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get range of field
         * @summary Get Range
         * @param {ConnectionNumberField} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRange(field: ConnectionNumberField, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRange(field, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * Get paginated Connections
         * @summary Get Connections
         * @param {string} [query] 
         * @param {Array<string>} [sortBy] 
         * @param {Array<boolean>} [sortDesc] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnections(query?: string, sortBy?: Array<string>, sortDesc?: Array<boolean>, page?: number, size?: number, options?: any): AxiosPromise<PageConnectionModel> {
            return localVarFp.getConnections(query, sortBy, sortDesc, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Get occurences count of field values
         * @summary Get Counts
         * @param {Array<ConnectionField>} fields 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounts(fields: Array<ConnectionField>, query?: string, options?: any): AxiosPromise<Array<CountModel>> {
            return localVarFp.getCounts(fields, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Download
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(connectionId: string, options?: any): AxiosPromise<DownloadModel> {
            return localVarFp.getDownload(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get global csv from connection
         * @summary Get Global Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalCsv(connectionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getGlobalCsv(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get global series from connection
         * @summary Get Globals
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobals(connectionId: string, size?: number, options?: any): AxiosPromise<Array<Array<number>>> {
            return localVarFp.getGlobals(connectionId, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Get panel zone series from connection
         * @summary Get Panel Zones
         * @param {string} connectionId 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelZones(connectionId: string, size?: number, options?: any): AxiosPromise<Array<Array<number>>> {
            return localVarFp.getPanelZones(connectionId, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Get panel zone csv from connection
         * @summary Get Panel Zones Csv
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPanelZonesCsv(connectionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getPanelZonesCsv(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get range of field
         * @summary Get Range
         * @param {ConnectionNumberField} field 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRange(field: ConnectionNumberField, options?: any): AxiosPromise<RangeModel> {
            return localVarFp.getRange(field, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * Get paginated Connections
     * @summary Get Connections
     * @param {string} [query] 
     * @param {Array<string>} [sortBy] 
     * @param {Array<boolean>} [sortDesc] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getConnections(query?: string, sortBy?: Array<string>, sortDesc?: Array<boolean>, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnections(query, sortBy, sortDesc, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get occurences count of field values
     * @summary Get Counts
     * @param {Array<ConnectionField>} fields 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getCounts(fields: Array<ConnectionField>, query?: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getCounts(fields, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Download
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getDownload(connectionId: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getDownload(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get global csv from connection
     * @summary Get Global Csv
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getGlobalCsv(connectionId: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getGlobalCsv(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get global series from connection
     * @summary Get Globals
     * @param {string} connectionId 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getGlobals(connectionId: string, size?: number, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getGlobals(connectionId, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get panel zone series from connection
     * @summary Get Panel Zones
     * @param {string} connectionId 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getPanelZones(connectionId: string, size?: number, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getPanelZones(connectionId, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get panel zone csv from connection
     * @summary Get Panel Zones Csv
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getPanelZonesCsv(connectionId: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getPanelZonesCsv(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get range of field
     * @summary Get Range
     * @param {ConnectionNumberField} field 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getRange(field: ConnectionNumberField, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getRange(field, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async root(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.root(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get Info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options?: any): AxiosPromise<Info> {
            return localVarFp.root(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get Info
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public root(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).root(options).then((request) => request(this.axios, this.basePath));
    }
}


